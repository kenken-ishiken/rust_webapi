---
description:
globs:
alwaysApply: false
---
# Rust WebAPI ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€Rust WebAPIãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ˆãä½¿ç”¨ã•ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã‚³ãƒãƒ³ãƒ‰ã®ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã§ã™ã€‚Phase 3å®Œäº†æ™‚ç‚¹ã§ã®æœ€æ–°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’åæ˜ ã—ã¦ã„ã¾ã™ã€‚

## ğŸš€ é–‹ç™ºãƒ•ãƒ­ãƒ¼

### åŸºæœ¬çš„ãªé–‹ç™ºã‚µã‚¤ã‚¯ãƒ«

```bash
# 1. é–‹ç™ºé–‹å§‹
cargo check                    # ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ç¢ºèª
cargo test --lib              # ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

# 2. æ–°æ©Ÿèƒ½é–‹ç™º
cargo test --lib <test_name>  # ç‰¹å®šãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
cargo run                     # ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œ

# 3. å“è³ªç¢ºèª
cargo clippy                  # Linterå®Ÿè¡Œ
cargo fmt                     # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
cargo test                    # å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

# 4. ã‚³ãƒŸãƒƒãƒˆ
git add .
git commit -m "feat: ..."
git push origin master
```

## ğŸ“ ã‚³ãƒ¼ãƒ‰ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

### ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®å®Ÿè£…

```rust
use crate::infrastructure::error::{AppError, AppResult};
use crate::infrastructure::metrics::Metrics;

pub struct ItemService {
    repository: Arc<dyn ItemRepository + Send + Sync>,
}

impl ItemService {
    pub async fn find_by_id(&self, id: u64) -> AppResult<ItemResponse> {
        Metrics::with_metrics("item", "find_by_id", async {
            let item = self.repository.find_by_id(id).await?;
            match item {
                Some(item) => Ok(self.to_response(item)),
                None => Err(AppError::not_found("Item", id)),
            }
        }).await
    }
}
```

### API ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å®Ÿè£…

```rust
use actix_web::{web, HttpResponse, Result as ActixResult};
use crate::infrastructure::error::AppError;

#[get("/items/{id}")]
pub async fn get_item(
    data: web::Data<AppState>,
    path: web::Path<u64>,
) -> ActixResult<HttpResponse> {
    let id = path.into_inner();
    
    match data.item_service.find_by_id(id).await {
        Ok(item) => Ok(HttpResponse::Ok().json(item)),
        Err(e) => Err(e.into()),
    }
}
```

### å‰Šé™¤æ“ä½œã®å®Ÿè£…

```rust
use crate::app_domain::service::deletion_service::DeleteKind;

// è«–ç†å‰Šé™¤
#[delete("/items/{id}")]
pub async fn delete_item(
    data: web::Data<AppState>,
    path: web::Path<u64>,
) -> ActixResult<HttpResponse> {
    let id = path.into_inner();
    data.deletion_facade.delete_item(id, DeleteKind::Logical).await?;
    Ok(HttpResponse::NoContent().finish())
}

// ç‰©ç†å‰Šé™¤
#[delete("/items/{id}/permanent")]
pub async fn permanent_delete_item(
    data: web::Data<AppState>,
    path: web::Path<u64>,
) -> ActixResult<HttpResponse> {
    let id = path.into_inner();
    data.deletion_facade.delete_item(id, DeleteKind::Physical).await?;
    Ok(HttpResponse::NoContent().finish())
}

// å¾©å…ƒ
#[post("/items/{id}/restore")]
pub async fn restore_item(
    data: web::Data<AppState>,
    path: web::Path<u64>,
) -> ActixResult<HttpResponse> {
    let id = path.into_inner();
    data.deletion_facade.delete_item(id, DeleteKind::Restore).await?;
    Ok(HttpResponse::Ok().json(json!({"message": "Item restored"})))
}
```

### ãƒ†ã‚¹ãƒˆã®å®Ÿè£…

```rust
#[tokio::test]
async fn test_find_by_id_success() {
    let mut mock_repo = MockItemRepository::new();
    mock_repo
        .expect_find_by_id()
        .with(eq(1u64))
        .return_once(|_| Ok(Some(create_test_item())));

    let service = ItemService::new(Arc::new(mock_repo));
    let result = service.find_by_id(1).await;

    assert!(result.is_ok());
}

#[tokio::test]
async fn test_find_by_id_not_found() {
    let mut mock_repo = MockItemRepository::new();
    mock_repo
        .expect_find_by_id()
        .with(eq(999u64))
        .return_once(|_| Ok(None));

    let service = ItemService::new(Arc::new(mock_repo));
    let result = service.find_by_id(999).await;

    assert!(matches!(result, Err(AppError::NotFound(_))));
}
```

## ğŸ”§ ã‚ˆãä½¿ã†ã‚³ãƒãƒ³ãƒ‰

### é–‹ç™ºã‚³ãƒãƒ³ãƒ‰

```bash
# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•
cargo run

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
cargo test test_find_by_id

# ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
cargo test --lib infrastructure::metrics::tests

# ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
./scripts/coverage.sh

# gRPCãƒ†ã‚¹ãƒˆ
./scripts/test_grpc.sh
```

### Docker ã‚³ãƒãƒ³ãƒ‰

```bash
# ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒèµ·å‹•
docker-compose up -d

# ãƒ­ã‚°ç¢ºèª
docker-compose logs -f rust_webapi

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
docker-compose exec postgres psql -U postgres -d rust_webapi

# ç’°å¢ƒåœæ­¢ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
docker-compose down -v
```

### k6 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

```bash
# ã‚¹ãƒ¢ãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ
cd k6 && npm run test:smoke

# ãƒ­ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ
cd k6 && npm run test:load

# ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ
cd k6 && npm run test:stress

# ã‚¹ãƒ‘ã‚¤ã‚¯ãƒ†ã‚¹ãƒˆ
cd k6 && npm run test:spike
```

## ğŸ“Š ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ»ãƒ­ã‚°ç¢ºèª

### ãƒ¡ãƒˆãƒªã‚¯ã‚¹ç¢ºèª

```bash
# Prometheusãƒ¡ãƒˆãƒªã‚¯ã‚¹ç¢ºèª
curl http://localhost:8080/metrics

# ç‰¹å®šãƒ¡ãƒˆãƒªã‚¯ã‚¹æ¤œç´¢
curl http://localhost:8080/metrics | grep api_success_total
```

### ãƒ­ã‚°ç¢ºèª

```bash
# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚°
docker-compose logs rust_webapi

# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ­ã‚°ç›£è¦–
docker-compose logs -f rust_webapi

# æ§‹é€ åŒ–ãƒ­ã‚°æ¤œç´¢ï¼ˆjqãŒå¿…è¦ï¼‰
docker-compose logs rust_webapi | jq 'select(.level == "ERROR")'
```

## ğŸ¯ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³

### AppError ã®ä½¿ç”¨

```rust
// âœ… æ¨å¥¨
AppError::not_found("Item", id)
AppError::validation_error("Invalid email format")
AppError::internal_error("Database connection failed")

// âŒ éæ¨å¥¨
Err(AppError::NotFound(format!("Item {} not found", id)))
anyhow::anyhow!("Something went wrong")
```

### Resultå‹ã®å‡¦ç†

```rust
// âœ… æ¨å¥¨ - Metrics::with_metricsä½¿ç”¨
Metrics::with_metrics("service", "operation", async {
    let result = repository.operation().await?;
    Ok(result)
}).await

// âœ… æ¨å¥¨ - æ‰‹å‹•ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
let timer = MetricsTimer::new("service", "operation");
let result = repository.operation().await?;
timer.observe();
Ok(result)
```

## ğŸ—‚ï¸ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³

### ä¸»è¦ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª

```
src/
â”œâ”€â”€ app_domain/          # ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤
â”‚   â”œâ”€â”€ model/          # ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«
â”‚   â”œâ”€â”€ repository/     # ãƒªãƒã‚¸ãƒˆãƒªãƒˆãƒ¬ã‚¤ãƒˆ
â”‚   â””â”€â”€ service/        # ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆå‰Šé™¤æˆ¦ç•¥ç­‰ï¼‰
â”œâ”€â”€ application/        # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
â”‚   â”œâ”€â”€ dto/           # ãƒ‡ãƒ¼ã‚¿è»¢é€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
â”‚   â””â”€â”€ service/       # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒ“ã‚¹
â”œâ”€â”€ infrastructure/    # ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤
â”‚   â”œâ”€â”€ error.rs       # ã‚¨ãƒ©ãƒ¼å®šç¾©
â”‚   â”œâ”€â”€ metrics/       # ãƒ¡ãƒˆãƒªã‚¯ã‚¹æ©Ÿèƒ½
â”‚   â”œâ”€â”€ config/        # è¨­å®šç®¡ç†
â”‚   â”œâ”€â”€ di/           # ä¾å­˜æ€§æ³¨å…¥
â”‚   â””â”€â”€ repository/    # ãƒªãƒã‚¸ãƒˆãƒªå®Ÿè£…
â””â”€â”€ presentation/      # ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤
    â”œâ”€â”€ api/          # REST API
    â””â”€â”€ grpc/         # gRPC API
```

### è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«

```
â”œâ”€â”€ Cargo.toml              # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
â”œâ”€â”€ docker-compose.yml      # ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒ
â”œâ”€â”€ Dockerfile              # ã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸
â”œâ”€â”€ initdb/                 # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
â”œâ”€â”€ k6/                     # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
â”œâ”€â”€ k8s/                    # Kubernetesè¨­å®š
â””â”€â”€ .cursor/rules/          # Cursoré–‹ç™ºãƒ«ãƒ¼ãƒ«
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ†ã‚¹ãƒˆãƒ¬ãƒ™ãƒ«

1. **ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ**: `cargo test --lib`
2. **çµ±åˆãƒ†ã‚¹ãƒˆ**: `cargo test --test integration_tests`
3. **Contract ãƒ†ã‚¹ãƒˆ**: `cargo test --test contract_deletion_strategy_tests`
4. **E2Eãƒ†ã‚¹ãƒˆ**: `cargo test --test e2e_tests`

### ãƒ¢ãƒƒã‚¯ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³

```rust
// MockRepositoryBuilderã®ä½¿ç”¨
let mock_repo = MockItemRepository::new()
    .with_find_by_id(1, Ok(Some(test_item())))
    .with_create(Ok(test_item()))
    .build();

// å¾“æ¥ã®mockallä½¿ç”¨
let mut mock_repo = MockItemRepository::new();
mock_repo
    .expect_find_by_id()
    .with(eq(1u64))
    .return_once(|_| Ok(Some(test_item())));
```

## ğŸ”— æœ‰ç”¨ãªãƒªãƒ³ã‚¯

### é–‹ç™ºãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- **[README.md](mdc:README.md)** - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
- **[CONTRIBUTING.md](mdc:CONTRIBUTING.md)** - ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‚¬ã‚¤ãƒ‰
- **[REMAINING_IMPROVEMENTS.md](mdc:REMAINING_IMPROVEMENTS.md)** - æ”¹å–„ã‚¿ã‚¹ã‚¯çŠ¶æ³

### API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- **[docs/api-reference.md](mdc:docs/api-reference.md)** - APIä»•æ§˜
- **[docs/grpc-api.md](mdc:docs/grpc-api.md)** - gRPC APIä»•æ§˜

### é‹ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- **[o11y.md](mdc:o11y.md)** - å¯è¦³æ¸¬æ€§ã‚¬ã‚¤ãƒ‰
- **[docs/deployment-operations.md](mdc:docs/deployment-operations.md)** - ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»é‹ç”¨ã‚¬ã‚¤ãƒ‰

## ğŸ“ˆ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç¾çŠ¶ï¼ˆPhase 3å®Œäº†æ™‚ç‚¹ï¼‰

### âœ… å®Œäº†æ¸ˆã¿æ©Ÿèƒ½

- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°çµ±ä¸€**: AppError 100%ä½¿ç”¨ã€unwrap/expecté™¤å»
- **ãƒ¡ãƒˆãƒªã‚¯ã‚¹çµ±ä¸€**: çµ±ä¸€ãƒã‚¯ãƒ­ãƒ»é«˜ãƒ¬ãƒ™ãƒ«APIå®Ÿè£…
- **å‰Šé™¤æˆ¦ç•¥çµ±ä¸€**: æˆ¦ç•¥ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ»ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…
- **ãƒ†ã‚¹ãƒˆæ”¹å–„**: MockBuilderã€Contract Testå®Ÿè£…
- **ä¾å­˜æ€§æ³¨å…¥**: DIã‚³ãƒ³ãƒ†ãƒŠå®Ÿè£…ã€main.rs 76è¡Œã«å‰Šæ¸›

### ğŸ”„ é€²è¡Œä¸­ãƒ»ä»Šå¾Œã®äºˆå®š

- **Phase 4-1**: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™ï¼ˆOpenAPI 3.0ã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å›³ï¼‰
- **Phase 4-2**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼ˆk6ãƒ†ã‚¹ãƒˆSLAæ¤œè¨¼ï¼‰
- **Phase 2-2**: Repositoryåˆ†å‰²å®Œäº†ï¼ˆInMemoryãƒªãƒã‚¸ãƒˆãƒªå®Ÿè£…ï¼‰

### ğŸ“Š å“è³ªæŒ‡æ¨™

- **ãƒ†ã‚¹ãƒˆæˆåŠŸç‡**: 100%ï¼ˆå…¨101ä»¶ï¼‰
- **Clippyè­¦å‘Š**: 0ä»¶
- **Dead codeè­¦å‘Š**: 0ä»¶
- **ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸**: æ¸¬å®šå¯èƒ½ï¼ˆcoverage.shä½¿ç”¨ï¼‰

---

ã“ã®ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚’æ´»ç”¨ã—ã¦ã€åŠ¹ç‡çš„ã§ä¸€è²«æ€§ã®ã‚ã‚‹Rust WebAPIé–‹ç™ºã‚’å®Ÿç¾ã—ã¦ãã ã•ã„ã€‚
